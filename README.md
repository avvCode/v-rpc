### 项目介绍
基于```Netty``` + ```Zookeeper``` 开发的一款RPC(远程过程调用)框架。并且基于SpringBoot开发了自定义starter，使用
```@VRefence```在调用端指向远程服务 + ```@VRpcService```在服务端暴露服务。支持服务注册、发现，负载均衡，支持多种序列化框架
<img alt="流程" height="600" src="doc/img.png" width="500"/>

这边的Client Stub和 Server Stub就是代理，客户端这边的代理屏蔽了请求的构造、结果的发送、结果获取，因为用户在意的只是调用方法并且将参数传进去，然后得到结果而已
而在Server Stub这个代理则屏蔽了调用服务方法、连接管理
### 项目模块树
#### 总体模块
```
├─rpc-framework-consumer                    -> 客户端测试
│  ├─rpc-framework-consumer-demo            -> 普通环境下
│  └─rpc-framework-consumer-spring          -> spring环境下
├─rpc-framework-core                        -> rpc项目核心代码
├─rpc-framework-interface                   -> 测试接口
├─rpc-framework-provider                    -> 服务端测试
│  ├─rpc-framework-provider-demo            -> 普通环境下
│  └─rpc-framework-provider-spring          -> spring环境下
└─rpc-framework-spring-boot-starter         -> 自定义spring-boot-starter 
```
#### core核心模块
```
├─client                                    -> 客户端相关类（启动类、连接管理类）
├─common                                    -> 通用包
│      ├─annotation                         -> 注解类
│      ├─cache                              -> 缓存类（客户端缓存、服务端缓存）
│      ├─config                             -> 配置类（客户端配置、服务端配置、配置加载类、配置读取类）
│      ├─constant                           -> 常量
│      ├─event                              -> 事件相关
├─dispatcher                                -> 服务端任务派发
├─filter                                    -> 过滤器（客户端过滤器、服务端过滤器）                                     
├─proxy                                     -> 代理层
├─registry                                  -> 接入注册中心层
├─router                                    -> 路由层
├─serialize                                 -> 序列化层
├─server                                    -> 服务端相关类（启动类、连接管理类、服务暴露类）
└─spi                                       -> spi插拔式组件相关（自定义加载类）支持key-value加载类
```
### 项目总体流程
#### 环境准备
- IDEA
- JDK 8
- Maven 3
- Zookeeper 单机或集群

#### 测试流程示例
方式一：
1. 将项目克隆到本地
    ```
    https://github.com/avvCode/v-rpc.git
    ```
2. 使用IDEA打开项目
   使用 IDEA 打开，等待项目初始化完成。
3. 开启Zookeeper
    默认式localhost，需要修改成自己的
4. 修改配置文件
5. 启动项目
6. 打开浏览器测试

### 实现概述
#### 整体结构

<img height="400" src="doc/img_1.png" width="1949"  alt=""/>




### 服务端 与 客户端的详细交互流程

#### 客户端
客户端在调用了代理类中的方法时，先构造请求RpcInvocation，然后放入任务队列中，此时这个线程拿着uuid阻塞循环等待结果

RpcInvocation：
- targetMethodName 请求的方法名
- args 方法参数
- attachments 附加参数
- uuid 请求唯一标识
- retry 重试次数
- ……

任务队列由专门地发送线程不断循环提取任务并且发送给服务端

结果的接收也是由Netty的专门地入站处理器，收到结果后，利用uuid作为接收结果评判标准

#### 服务端
服务端有专门地入站处理器，此时也是参考Reactor高性能网络模型，接收请求后，将请求提交给线程池，线程池中不断拿取任务，并且通过反射，找到需要调用的方法
执行完毕后发送回客户端

**这里用到的异步设计**

- 客户端：等待结果不阻塞任务发送

- 服务端：并发处理任务，接收任务与处理任务解耦，提高吞吐率


#### 代理层 Proxy
引入代理层的原因

首先为什么需要代理？

客户端并没有服务的实现，而是只有接口，那么这个时候如何去调用接口方法？此时可以选择代理。

代理分为动态代理和静态代理，静态代理的话，需要我们自己去实现这个接口，并且在其中实现中调用真正的服务，那这并不是我们想要的。

动态代理，动态代理主要使用的是JDK中的动态代理，主要依靠的是两个核心类，一个是Proxy中的newInstance，用来获取代理对象，一个是InvocationHandler，实现这个接口
就可以利用其中的invoke方法，invoke方法的入参可以拿到调用的参数信息，这样我们就可以在其中进行参数包裹，请求构造。


##### 1.1 支持JDK代理

##### 1.2 支持Javassist代理



#### 注册中心层 Registry
引入注册中心，可以感知服务端的上线与下线，心跳机制
保证一致性时，在集群中，只允许一个节点写入，在写入的时候，其他的所有节点都会阻塞，直到数据同步完成
为什么用了zk，CAP理论，zk采用CP。RPC服务一致性要求高，不能说服务端挂了依旧保存着连接信息。
nacos及支持CP 也支持AP，这个可以配置。每隔十秒进行服务轮询更新，主要采用Map来保存数据信息，当配置了数据库，那么这些数据将会持久化
eraka支持AP，每隔30s进行一次轮询，进行服务变更
consul

扩展：Zookeeper的其他用法
- 分布式锁：利用创建临时顺序节点作为分布式锁，使用完成后将该节点删除，作为释放锁操作
- 分布式ID：利用顺序节点，可以创建一个独一无二的分布式ID
- 配置中心：对于Zk来说，就是通过一个个znode节点来保存数据，类似于多叉树。而配置变更则是利用监听机制，当服务变动，通知订阅方修改或者取消订阅。

##### 2.1 支持 Zookeeper注册中心

#### 路由层 Router

为什么需要路由？

- 机器性能不太一致
- 提供的服务有多个

如何实现路由层？
很简单，在进行启动的时候，将服务信息保存到客户端，并且有一个专门的连接数组，存放着这些连接。在任务处理的时候，经过路由层的路由策略选择一个连接
进行发送请求

##### 3.1 随机路由
使用Random函数

##### 3.2 轮训路由 
原子类取模操作，为什么，因为对于一个变量的修改，不是原子的，多线程操作会出现并发问题，达不到想要的效果

##### 扩展
还有哪些路由策略

##### 按权随机分配
实现按权随机分配，需要为服务设定权重，权重较大的服务将多分配请求，权重小的则分配少一点请求

##### 一致性哈希



#### 序列化层 Serialize
序列化层的设计，主要是对于两边传输的设计

网络传输的方式有两大类，文本类，二进制类。

我采用的是二进制类，计算机好识别，并且传输快

粘包问题、半包问题。原本发送一句话，此时确收到了两句话，这是半包问题。原本发送了两句话，此时却收到了一句话，这是粘包问题
业界的话主要有三种处理方式吧

第一种是固定长度，比如说我一个包64个字节，你就给我固定这么大，我每次也读这么大。灵活性比较差

第二种是特殊字符结尾，不过万一数据流中间存在这个特殊字符，那么处理起来就会很麻烦

第三种就是自定义协议。那我也是采用第三种解决方式

采用自定义协议的方式

RpcProtocol

- Magic 魔数
- length当前发送包的长度
- content 发送数据的二进制码

如何选择序列化协议
无非就是 传输速度，这个和转化对象成为二进制码流大小有关
是否跨语言，像JDK就不支持跨语言

##### 4.1 支持JDK序列化

##### 4.2 支持Hessian序列化

##### 4.3 支持Kryo序列化
 
##### 4.4 支持FastJson序列化

测试码流大小作为评判序列化的优劣，自测的话FastJson比较好，对同样的10不同对象产生的码流最小，而对于JDK，产生的码流最大

#### 添加职责链 Filter

服务分组、直连调用、token鉴权

##### 5.1 支持服务分组

##### 5.2 支持ip直连（发现两个相同服务返回结果不同指定ip进行debug）

##### 5.3 添加请求日志（请求时间、调用方信息、请求方法、请求耗时）
职责链模式，涉及的就是多态，一个处理父类接口，里面只有一个handler方法，
作为所有实现子类的基类，一个调用类，里面只有一个List集合，存储着所有职责链的实例对象，而这个对象之需要在启动时new出来一个静态实例，在
请求处理的时候，也只是一句话的事，也就不用写那么多的if else，而且给用户扩展性也比较低 

#### 支持SPI可插拔式组件
Dubbo微内核的设计思想，也叫做插件式架构
里面有核心系统，和插件模块
这个实现方式就是工厂设计模式 + SPI机制。

说到SPI，他和API很像。比如在写业务的时候，会写一个接口类，然后再去写一个impl类，我们在上层调用的时候，依旧调用的是这个接口。这个是API
那SPI的话，就像现在的电脑一样，生产电脑的厂商提供了鼠标、键盘的这套规范，而市面上非常多的键盘、鼠标生产商，只要遵循这个规范，就可以批量生产了，而
对于电脑来说，最终的结果都一样，什么样的键盘只要符合规范，就可以用了。
SPI就是这样的思想，由核心模块设计规范，由组件遵循规范。API就是组件设计规范，核心模块遵循规范并且调用

而进行加载其实并不仅仅是加载一个类，所以采用了key-value的调用形式，加载类。
自定义了ExtensionLoader，去加载Resource下的META-INF下的v-rpc中的类及其实现。并且还是顺序存储这些类的.class对象。在需要的时候，
再将其实例对象new出来

不仅仅是利用工厂，也可以用职责链设计模式，实现用户自定义前置过滤器，后置过滤器。


##### 6.1 自定义key-value式SPI类加载方式

##### 6.2 实行按需加载（懒加载模式）

#### 请求接收与请求处理解耦
##### 7.1 改造服务端只在一个Handler中处理请求为**缓冲队列** + **业务线程池**处理请求

#### 容错层设计

##### 8.1 支持客户端接收并显示服务端异常
如果返回结果一直为null，则会判定为客户端异常或者是请求超时

##### 8.2 服务端接口限流
限流针对的主要是瞬时流量激增导致服务处理不过，这个时候，需要对服务进行限流熔断、限流操作


##### 8.3 客户端支持超时重试
对于重试而言，是存在一些业务不能重复尝试的，像一些金融业务。这个重试使用需要非常谨慎。所以的话，这边也是提供了重试次数的设置。
这个重试次数在超时的时候会用到。在Spring环境下，直接在注解上定义就可以了

#### 压测
用ab测试，梯度服务请求10/100/1000服务耗时

#### 结合SpringBoot Starter 使用
SpringBoot Starter其实也是一种SPI机制，需要引用一个依赖，然后还要在Resource目录的META-INF下的spring.factoies中定义
需要自动装配的Bean的全类名。如果有多个的话，需要使用/,的方式隔开。另外，他其实也支持key-value的装配方式。


核心思想：当前服务即是客户端、也是服务端，什么时候可以进行服务暴露？什么时候可以获取到bean里面的属性？
因为我想采用的是注解的方式，用@VReference指向远程服务类，这个是放在字段上的。@VService进行服务暴露，这个是放在类上的注解

简单说说Bean的生命周期
- 实例化阶段，这个时期，会将Spring配置、或者注解的Bean放进IOC容器中
- 属性注入阶段，这个阶段，会将一些Bean与Bean之间的依赖进行注入，比如说setter注入等
- 初始化阶段
- 使用阶段
- 销毁阶段

Spring提供了很多Bean后处理器的扩展方法，而我选择的是在属性注入之后，初始化客户端，因为我需要获取所有的字段，而其中就怕他没有
依赖注入。所以时机一定是选择属性注入之后的。而我选择就是在初始化阶段进行客户端初始化。
对于服务端，在Bean加载进IOC容器时就足够了，所以按理来说，在属性阶段就可以进行服务暴露了。我直接选择了在初始化阶段进行
服务暴露。


